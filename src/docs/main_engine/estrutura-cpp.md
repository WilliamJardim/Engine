**Nota escrita 06/08/2025 17:28 PM**, por William Alves Jardim, explicando a estrutura de classes da minha Engine de logica/física(que está atualmente na subpasta `src/engine/core/`), que eu planejei e construí especificamente para esse projeto, ao longo do desenvolvimento dele.

Criei essa nota para descrever em detalhes a estrutura de classes de minha Engine de lógica/fisica, para fins de documentação, aprendizado e posterior consulta por mim caso um dia eu queria migrar meu código pra C++. 

Essa é a estrutura que eu planejei para meu código TypeScript ser **100% portável para C++**, fazendo uso de conceitos presentes na linguagem C++ dentro do TypeScript, como **polimorfismo, herança, ponteiros, structs e metodos virtuais.**
Eu planejei isso e fui construindo essa estrutura gradualmente, ao longo do desenvolvimento desse projeto.

A estrutura atual da minha Engine de lógica/fisica é a seguinte, abaixo:

## Estrutura atual Engine lógica/fisica
`AbstractObjectBase.ts`: usa declaração antecipada do Scene. Mais não implementa nenhum método nem faz nenhum uso do Scene. Apenas tem métodos abstratos e declara o uso de Scene.

`Scene.ts`: declara o Scene com todos os métodos e atributos. A definição completa mesmo. Porém, tem um detalhe importante que poderia soar confuso ou fora de ordem sequencial, se não prestar atenção ao polimorfismo: O `Scene` armazena num Array(isso é, o array `objects`) todos os objetos da cena(que são na verdade, ponteiros do tipo `AbstractObjectBase` , por causa do uso do polimorfismo, para permitir que objetos usem herança de uma classe base e que possam ser generalizados na lógica do jogo). E além disso, como mencionei acima, entre parênteses, eu uso ponteiros e polimorfismo, então, todos os objetos vão ser instâncias derivadas de `AbstractObjectBase`, o que permite que essa minha lógica exista e funcione como eu planejei: pois um objeto pode ser `NULLPTR` ou uma instância de `AbstractObjectBase` ou qualquer classe que herda ele diretamente, pois o polimorfismo permite isso, o que é bem flexível pra o que eu quero fazer. A minha única preocupação vai ser que, eu implemente corretamente os métodos abstratos na definição seguinte: `ObjectBase`. É que o Scene só chama métodos que o `AbstractObjectBase` declarou. Por exemplo, para atualizar os objetos, o `Scene` chama `objetoAtual.updateObject();`, e para repassar o contexto da cena para o ponteiro `scene` dentro do `objetoAtual` ele faz `objetoAtual.setScene( cenaAtual );`. Na classe `AbstractObjectBase`, os métodos `setScene` e `updateObject` apenas existem como métodos virtuais, porém eles não tem implantação. A implantação só existe na classe `ObjectBase`, e em todas as outras classes que houver atualização de objetos.
    
`ObjectBase.ts`: Herda o `AbstractObjectBase`. Esse sim implementa cada um dos métodos que o `AbstractObjectBase` declarou(implementa `setScene`, `updateObject` e muitos outros). E esse sim, faz uso dos atributos e métodos do `Scene`. Porém, a `Scene` precisa existir, com todos os métodos e atributos dela. Por isso declarei ela acima, para eu conseguir acessar ela livremente.

`Player.ts`: atualmente herda o `ObjectBase`, o que facilitaria muito as coisas, por já ter metodos que eu já defini no `ObjectBase`, e o player vai se comportar de forma bem parecida com um `ObjectBase`, então eu pensando só por esse lado deixaria assim mesmo. 
*MAS AGORA VEM PARTE COMPLEXA*: Isso quebraria o meu fluxo que eu planejei pro C++, pois o `Scene` não pode conhecer a definição do `ObjectBase`, caso contrário, eu teria que fazer de outras formas para o C++ poder aceitar essa lógica, mais não dá forma como eu planejei em TS/C++, e isso iria deixar a lógica confusa e complexa. Talvez não valha a pena manter dessa forma.

Por isso, refletindo bastante, acredito que o ideal seria o Player herdar a classe `AbstractObjectBase`, e implementar cada um dos métodos denovo, só que individualizado para o `Player`. A única desvantagem disso seria que eu teria que ter códigos duplicados pra tudo: pois todos os métodos que o `ObjectBase` precisa implementar para funcionar, o player também vai precisar implementar da mesma forma. O que vai gerar código duplicado. E a única forma que vejo de isso não acontecer e não duplicar código seria refatorando a estrutura da minha Engine de lógica assim como eu pensei naquela minha ideia(citar), transferindo toda a lógica de física, eventos, colisão, etc do ObjectBase para o `Scene`, eliminando a necessidade de implementar eles no `ObjectBase` e no `Player` e em outras classes que eu criar que herdem `AbstractObjectBase`. Mais para isso, eu teria que centralizar tudo no Scene, ficaria um código um pouco mais procedural, mais ainda assim orientado a objetos, usando os objetos principalmente pra armazenar informações que independem do `Scene`, e para ter alguns métodos que manipulam os próprios atributos deles. E pra valer a pena isso, eu preciso tentar otimizar os laços de repetição FOR 

**Eu desenvolvi essa estrutura de classes ao longo do desenvolvimento deste projeto, com intuito de ser 100% compativel para uma migração em C++, por seguir os conceitos de polimorfismo, herança, ponteiros, structs e metodos virtuais.**
